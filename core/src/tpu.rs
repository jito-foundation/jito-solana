//! The `tpu` module implements the Transaction Processing Unit, a
//! multi-stage transaction processing pipeline in software.

pub use crate::forwarding_stage::ForwardingClientOption;
use {
    crate::{
        admin_rpc_post_init::{KeyUpdaterType, KeyUpdaters},
        banking_stage::{
            transaction_scheduler::scheduler_controller::SchedulerConfig, BankingControlMsg,
            BankingStage, BankingStageHandle,
        },
        banking_trace::{Channels, TracerThread},
        // bundle_stage::bundle_account_locker::BundleAccountLocker,
        cluster_info_vote_listener::{
            ClusterInfoVoteListener, DuplicateConfirmedSlotsSender, GossipVerifiedVoteHashSender,
            VerifiedVoteSender, VoteTracker,
        },
        fetch_stage::FetchStage,
        forwarding_stage::{
            spawn_forwarding_stage, ForwardAddressGetter, SpawnForwardingStageResult,
        },
        proxy::{
            block_engine_stage::{BlockBuilderFeeInfo, BlockEngineConfig, BlockEngineStage},
            fetch_stage_manager::FetchStageManager,
            relayer_stage::{RelayerConfig, RelayerStage},
        },
        sigverify::TransactionSigVerifier,
        sigverify_stage::SigVerifyStage,
        staked_nodes_updater_service::StakedNodesUpdaterService,
        // tip_manager::{TipManager, TipManagerConfig},
        tpu_entry_notifier::TpuEntryNotifier,
        validator::{BlockProductionMethod, GeneratorConfig},
        vortexor_receiver_adapter::VortexorReceiverAdapter,
    },
    arc_swap::ArcSwap,
    bytes::Bytes,
    crossbeam_channel::{bounded, unbounded, Receiver},
    solana_clock::Slot,
    solana_gossip::cluster_info::ClusterInfo,
    solana_keypair::Keypair,
    solana_ledger::{
        blockstore::Blockstore, blockstore_processor::TransactionStatusSender,
        entry_notifier_service::EntryNotifierSender,
    },
    solana_perf::data_budget::DataBudget,
    solana_poh::{
        poh_recorder::{PohRecorder, WorkingBankEntry},
        transaction_recorder::TransactionRecorder,
    },
    solana_pubkey::Pubkey,
    solana_rpc::{
        optimistically_confirmed_bank_tracker::BankNotificationSenderConfig,
        rpc_subscriptions::RpcSubscriptions,
    },
    solana_runtime::{
        bank::Bank,
        bank_forks::BankForks,
        prioritization_fee_cache::PrioritizationFeeCache,
        vote_sender_types::{ReplayVoteReceiver, ReplayVoteSender},
    },
    solana_signer::Signer,
    solana_streamer::{
        quic::{
            spawn_simple_qos_server, spawn_stake_wighted_qos_server, SimpleQosQuicStreamerConfig,
            SpawnServerResult, SwQosQuicStreamerConfig,
        },
        streamer::StakedNodes,
    },
    solana_turbine::{
        broadcast_stage::{BroadcastStage, BroadcastStageType},
        xdp::XdpSender,
    },
    std::{
        collections::HashMap,
        net::{SocketAddr, UdpSocket},
        num::NonZeroUsize,
        sync::{atomic::AtomicBool, Arc, Mutex, RwLock},
        thread::{self, JoinHandle},
        time::Duration,
    },
    tokio::sync::{mpsc, mpsc::Sender as AsyncSender},
    tokio_util::sync::CancellationToken,
};
use {
    crate::{
        bundle_sigverify_stage::BundleSigverifyStage,
        bundle_stage::{bundle_account_locker::BundleAccountLocker, BundleStage},
        tip_manager::{TipManager, TipManagerConfig},
    },
    ahash::{HashSet, HashSetExt},
};

pub struct TpuSockets {
    pub transactions: Vec<UdpSocket>,
    pub transaction_forwards: Vec<UdpSocket>,
    pub vote: Vec<UdpSocket>,
    pub broadcast: Vec<UdpSocket>,
    pub transactions_quic: Vec<UdpSocket>,
    pub transactions_forwards_quic: Vec<UdpSocket>,
    pub vote_quic: Vec<UdpSocket>,
    /// Client-side socket for the forwarding votes.
    pub vote_forwarding_client: UdpSocket,
    pub vortexor_receivers: Option<Vec<UdpSocket>>,
}

/// The `SigVerifier` enum is used to determine whether to use a local or remote signature verifier.
enum SigVerifier {
    Local(SigVerifyStage),
    Remote(VortexorReceiverAdapter),
}

impl SigVerifier {
    fn join(self) -> thread::Result<()> {
        match self {
            SigVerifier::Local(sig_verify_stage) => sig_verify_stage.join(),
            SigVerifier::Remote(vortexor_receiver_adapter) => vortexor_receiver_adapter.join(),
        }
    }
}

// Conservatively allow 20 TPS per validator.
pub const MAX_VOTES_PER_SECOND: u64 = 20;

/// For the first `reserved_ticks` ticks of a bank, the preallocated_bundle_cost is subtracted
/// from the Bank's block cost limit.
fn calculate_block_cost_limit_reservation(
    bank: &Bank,
    reserved_ticks: u64,
    preallocated_bundle_cost: u64,
) -> u64 {
    if bank.tick_height() % bank.ticks_per_slot() < reserved_ticks {
        preallocated_bundle_cost
    } else {
        0
    }
}

pub struct Tpu {
    fetch_stage: FetchStage,
    sig_verifier: SigVerifier,
    vote_sigverify_stage: SigVerifyStage,
    banking_stage: BankingStageHandle,
    forwarding_stage: JoinHandle<()>,
    cluster_info_vote_listener: ClusterInfoVoteListener,
    broadcast_stage: BroadcastStage,
    tpu_quic_t: Option<thread::JoinHandle<()>>,
    tpu_forwards_quic_t: Option<thread::JoinHandle<()>>,
    tpu_entry_notifier: Option<TpuEntryNotifier>,
    staked_nodes_updater_service: StakedNodesUpdaterService,
    tracer_thread_hdl: TracerThread,
    tpu_vote_quic_t: thread::JoinHandle<()>,
    relayer_stage: RelayerStage,
    block_engine_stage: BlockEngineStage,
    fetch_stage_manager: FetchStageManager,
    bundle_stage: BundleStage,
    bundle_sigverify_stage: BundleSigverifyStage,
}

impl Tpu {
    #[allow(clippy::too_many_arguments)]
    pub fn new_with_client(
        cluster_info: &Arc<ClusterInfo>,
        poh_recorder: &Arc<RwLock<PohRecorder>>,
        transaction_recorder: TransactionRecorder,
        entry_receiver: Receiver<WorkingBankEntry>,
        retransmit_slots_receiver: Receiver<Slot>,
        sockets: TpuSockets,
        subscriptions: Option<Arc<RpcSubscriptions>>,
        transaction_status_sender: Option<TransactionStatusSender>,
        entry_notification_sender: Option<EntryNotifierSender>,
        blockstore: Arc<Blockstore>,
        broadcast_type: &BroadcastStageType,
        xdp_sender: Option<XdpSender>,
        exit: Arc<AtomicBool>,
        shred_version: u16,
        vote_tracker: Arc<VoteTracker>,
        bank_forks: Arc<RwLock<BankForks>>,
        verified_vote_sender: VerifiedVoteSender,
        gossip_verified_vote_hash_sender: GossipVerifiedVoteHashSender,
        replay_vote_receiver: ReplayVoteReceiver,
        replay_vote_sender: ReplayVoteSender,
        bank_notification_sender: Option<BankNotificationSenderConfig>,
        duplicate_confirmed_slot_sender: DuplicateConfirmedSlotsSender,
        client: ForwardingClientOption,
        turbine_quic_endpoint_sender: AsyncSender<(SocketAddr, Bytes)>,
        keypair: &Keypair,
        log_messages_bytes_limit: Option<usize>,
        staked_nodes: &Arc<RwLock<StakedNodes>>,
        shared_staked_nodes_overrides: Arc<RwLock<HashMap<Pubkey, u64>>>,
        banking_tracer_channels: Channels,
        tracer_thread_hdl: TracerThread,
        tpu_enable_udp: bool,
        tpu_quic_server_config: SwQosQuicStreamerConfig,
        tpu_fwd_quic_server_config: SwQosQuicStreamerConfig,
        vote_quic_server_config: SimpleQosQuicStreamerConfig,
        prioritization_fee_cache: &Arc<PrioritizationFeeCache>,
        block_production_method: BlockProductionMethod,
        block_production_num_workers: NonZeroUsize,
        block_production_scheduler_config: SchedulerConfig,
        enable_block_production_forwarding: bool,
        _generator_config: Option<GeneratorConfig>, /* vestigial code for replay invalidator */
        key_notifiers: Arc<RwLock<KeyUpdaters>>,
        banking_control_receiver: mpsc::Receiver<BankingControlMsg>,
        cancel: CancellationToken,
        block_engine_config: Arc<Mutex<BlockEngineConfig>>,
        relayer_config: Arc<Mutex<RelayerConfig>>,
        tip_manager_config: TipManagerConfig,
        shred_receiver_address: Arc<ArcSwap<Option<SocketAddr>>>,
        preallocated_bundle_cost: u64,
    ) -> Self {
        let TpuSockets {
            transactions: transactions_sockets,
            transaction_forwards: tpu_forwards_sockets,
            vote: tpu_vote_sockets,
            broadcast: broadcast_sockets,
            transactions_quic: transactions_quic_sockets,
            transactions_forwards_quic: transactions_forwards_quic_sockets,
            vote_quic: tpu_vote_quic_sockets,
            vote_forwarding_client: vote_forwarding_client_socket,
            vortexor_receivers,
        } = sockets;

        // [----------]
        // [-- QUIC --] \
        // [----------]  \____     [-----------------------]     [--------------------]     [------------------]
        //                    ---- [-- FetchStageManager --] --> [-- SigverifyStage --] --> [-- BankingStage --]
        // [--------------]  /     [-----------------------]     [--------------------]     [------------------]
        // [-- Vortexor --] /
        // [--------------]
        //
        //             fetch_stage_manager_*                packet_receiver

        // Packets from fetch stage and quic server are intercepted and sent through fetch_stage_manager
        // If relayer is connected, packets are dropped. If not, packets are forwarded on to packet_sender
        let (fetch_stage_manager_sender, fetch_stage_manager_receiver) = unbounded();
        let (sigverify_stage_sender, sigverify_stage_receiver) = unbounded();

        let (vote_packet_sender, vote_packet_receiver) = unbounded();
        let (forwarded_packet_sender, forwarded_packet_receiver) = unbounded();
        let fetch_stage = FetchStage::new_with_sender(
            transactions_sockets,
            tpu_forwards_sockets,
            tpu_vote_sockets,
            exit.clone(),
            &fetch_stage_manager_sender,
            &vote_packet_sender,
            &forwarded_packet_sender,
            forwarded_packet_receiver,
            poh_recorder,
            None, // coalesce
            Some(bank_forks.read().unwrap().get_vote_only_mode_signal()),
            tpu_enable_udp,
        );

        let staked_nodes_updater_service = StakedNodesUpdaterService::new(
            exit.clone(),
            bank_forks.clone(),
            staked_nodes.clone(),
            shared_staked_nodes_overrides,
        );

        let Channels {
            non_vote_sender: banking_stage_sender,
            non_vote_receiver: banking_stage_receiver,
            tpu_vote_sender,
            tpu_vote_receiver,
            gossip_vote_sender,
            gossip_vote_receiver,
        } = banking_tracer_channels;

        // Streamer for Votes:
        let SpawnServerResult {
            endpoints: _,
            thread: tpu_vote_quic_t,
            key_updater: vote_streamer_key_updater,
        } = spawn_simple_qos_server(
            "solQuicTVo",
            "quic_streamer_tpu_vote",
            tpu_vote_quic_sockets,
            keypair,
            vote_packet_sender.clone(),
            staked_nodes.clone(),
            vote_quic_server_config.quic_streamer_config,
            vote_quic_server_config.qos_config,
            cancel.clone(),
        )
        .unwrap();

        let (tpu_quic_t, key_updater) = if vortexor_receivers.is_none() {
            // Streamer for TPU
            let SpawnServerResult {
                endpoints: _,
                thread: tpu_quic_t,
                key_updater,
            } = spawn_stake_wighted_qos_server(
                "solQuicTpu",
                "quic_streamer_tpu",
                transactions_quic_sockets,
                keypair,
                fetch_stage_manager_sender.clone(),
                staked_nodes.clone(),
                tpu_quic_server_config.quic_streamer_config,
                tpu_quic_server_config.qos_config,
                cancel.clone(),
            )
            .unwrap();
            (Some(tpu_quic_t), Some(key_updater))
        } else {
            (None, None)
        };

        let (tpu_forwards_quic_t, forwards_key_updater) = if vortexor_receivers.is_none() {
            // Streamer for TPU forward
            let SpawnServerResult {
                endpoints: _,
                thread: tpu_forwards_quic_t,
                key_updater: forwards_key_updater,
            } = spawn_stake_wighted_qos_server(
                "solQuicTpuFwd",
                "quic_streamer_tpu_forwards",
                transactions_forwards_quic_sockets,
                keypair,
                forwarded_packet_sender,
                staked_nodes.clone(),
                tpu_fwd_quic_server_config.quic_streamer_config,
                tpu_fwd_quic_server_config.qos_config,
                cancel,
            )
            .unwrap();
            (Some(tpu_forwards_quic_t), Some(forwards_key_updater))
        } else {
            (None, None)
        };

        let (forward_stage_sender, forward_stage_receiver) = bounded(1024);
        let sig_verifier = if let Some(vortexor_receivers) = vortexor_receivers {
            info!("starting vortexor adapter");
            let sockets = vortexor_receivers.into_iter().map(Arc::new).collect();
            let adapter = VortexorReceiverAdapter::new(
                sockets,
                Duration::from_millis(5),
                banking_stage_sender.clone(),
                enable_block_production_forwarding.then(|| forward_stage_sender.clone()),
                exit.clone(),
            );
            SigVerifier::Remote(adapter)
        } else {
            info!("starting regular sigverify stage");
            let verifier = TransactionSigVerifier::new(
                banking_stage_sender.clone(),
                enable_block_production_forwarding.then(|| forward_stage_sender.clone()),
            );
            SigVerifier::Local(SigVerifyStage::new(
                sigverify_stage_receiver,
                verifier,
                "solSigVerTpu",
                "tpu-verifier",
            ))
        };

        let vote_sigverify_stage = {
            let verifier = TransactionSigVerifier::new_reject_non_vote(
                tpu_vote_sender,
                Some(forward_stage_sender),
            );
            SigVerifyStage::new(
                vote_packet_receiver,
                verifier,
                "solSigVerTpuVot",
                "tpu-vote-verifier",
            )
        };

        let block_builder_fee_info = Arc::new(Mutex::new(BlockBuilderFeeInfo {
            block_builder: cluster_info.keypair().pubkey(),
            block_builder_commission: 0,
        }));

        let shredstream_receiver_address = Arc::new(ArcSwap::from_pointee(None)); // set by `[BlockEngineStage::connect_auth_and_stream()]`
        let (unverified_bundle_sender, unverified_bundle_receiver) = bounded(1024);
        let block_engine_stage = BlockEngineStage::new(
            block_engine_config,
            unverified_bundle_sender,
            cluster_info.clone(),
            sigverify_stage_sender.clone(),
            banking_stage_sender.clone(),
            exit.clone(),
            &block_builder_fee_info,
            shredstream_receiver_address.clone(),
        );
        let (verified_bundle_sender, verified_bundle_receiver) = bounded(1024);
        let bundle_sigverify_stage = BundleSigverifyStage::new(
            unverified_bundle_receiver,
            verified_bundle_sender,
            exit.clone(),
        );

        let (heartbeat_tx, heartbeat_rx) = unbounded();
        let fetch_stage_manager = FetchStageManager::new(
            cluster_info.clone(),
            heartbeat_rx,
            fetch_stage_manager_receiver,
            sigverify_stage_sender.clone(),
            exit.clone(),
        );

        let relayer_stage = RelayerStage::new(
            relayer_config,
            cluster_info.clone(),
            heartbeat_tx,
            sigverify_stage_sender,
            exit.clone(),
        );

        let cluster_info_vote_listener = ClusterInfoVoteListener::new(
            exit.clone(),
            cluster_info.clone(),
            gossip_vote_sender,
            vote_tracker,
            bank_forks.clone(),
            subscriptions,
            verified_vote_sender,
            gossip_verified_vote_hash_sender,
            replay_vote_receiver,
            blockstore.clone(),
            bank_notification_sender,
            duplicate_confirmed_slot_sender,
        );

        let bundle_account_locker = BundleAccountLocker::default();

        // The tip program can't be used in BankingStage to avoid someone from stealing tips mid-slot.
        // The first 80% of the block, based on poh ticks, has `preallocated_bundle_cost` less compute units.
        // The last 20% has has full compute so blockspace is maximized if BundleStage is idle.
        let reserved_ticks = poh_recorder
            .read()
            .unwrap()
            .ticks_per_slot()
            .saturating_mul(8)
            .saturating_div(10);

        let tip_manager = TipManager::new(tip_manager_config);
        let mut blacklisted_accounts = HashSet::new();
        blacklisted_accounts.insert(tip_manager.tip_payment_program_id());

        let banking_stage = BankingStage::new_num_threads(
            block_production_method,
            poh_recorder.clone(),
            transaction_recorder.clone(),
            banking_stage_receiver,
            tpu_vote_receiver,
            gossip_vote_receiver,
            banking_control_receiver,
            block_production_num_workers,
            block_production_scheduler_config,
            transaction_status_sender.clone(),
            replay_vote_sender.clone(),
            log_messages_bytes_limit,
            bank_forks.clone(),
            prioritization_fee_cache.clone(),
            blacklisted_accounts.clone(),
            bundle_account_locker.clone(),
            move |bank| {
                calculate_block_cost_limit_reservation(
                    bank,
                    reserved_ticks,
                    preallocated_bundle_cost,
                )
            },
        );

        let SpawnForwardingStageResult {
            join_handle: forwarding_stage,
            client_updater,
        } = spawn_forwarding_stage(
            forward_stage_receiver,
            client,
            vote_forwarding_client_socket,
            bank_forks.read().unwrap().sharable_banks(),
            ForwardAddressGetter::new(cluster_info.clone(), poh_recorder.clone()),
            DataBudget::default(),
        );

        let bundle_stage = BundleStage::new(
            cluster_info,
            bank_forks.clone(),
            poh_recorder,
            transaction_recorder,
            verified_bundle_receiver,
            transaction_status_sender,
            replay_vote_sender,
            log_messages_bytes_limit,
            exit.clone(),
            tip_manager,
            bundle_account_locker,
            &block_builder_fee_info,
            prioritization_fee_cache,
            blacklisted_accounts,
        );

        let (entry_receiver, tpu_entry_notifier) =
            if let Some(entry_notification_sender) = entry_notification_sender {
                let (broadcast_entry_sender, broadcast_entry_receiver) = unbounded();
                let tpu_entry_notifier = TpuEntryNotifier::new(
                    entry_receiver,
                    entry_notification_sender,
                    broadcast_entry_sender,
                    exit.clone(),
                );
                (broadcast_entry_receiver, Some(tpu_entry_notifier))
            } else {
                (entry_receiver, None)
            };

        let broadcast_stage = broadcast_type.new_broadcast_stage(
            broadcast_sockets,
            cluster_info.clone(),
            entry_receiver,
            retransmit_slots_receiver,
            exit,
            blockstore,
            bank_forks,
            shred_version,
            turbine_quic_endpoint_sender,
            xdp_sender,
            shredstream_receiver_address,
            shred_receiver_address,
        );

        let mut key_notifiers = key_notifiers.write().unwrap();
        if let Some(key_updater) = key_updater {
            key_notifiers.add(KeyUpdaterType::Tpu, key_updater);
        }
        if let Some(forwards_key_updater) = forwards_key_updater {
            key_notifiers.add(KeyUpdaterType::TpuForwards, forwards_key_updater);
        }
        key_notifiers.add(KeyUpdaterType::TpuVote, vote_streamer_key_updater);

        key_notifiers.add(KeyUpdaterType::Forward, client_updater);

        Self {
            fetch_stage,
            sig_verifier,
            vote_sigverify_stage,
            banking_stage,
            forwarding_stage,
            cluster_info_vote_listener,
            broadcast_stage,
            tpu_quic_t,
            tpu_forwards_quic_t,
            tpu_entry_notifier,
            staked_nodes_updater_service,
            tracer_thread_hdl,
            tpu_vote_quic_t,
            block_engine_stage,
            relayer_stage,
            fetch_stage_manager,
            bundle_stage,
            bundle_sigverify_stage,
        }
    }

    pub fn join(self) -> thread::Result<()> {
        let results = vec![
            self.fetch_stage.join(),
            self.sig_verifier.join(),
            self.vote_sigverify_stage.join(),
            self.cluster_info_vote_listener.join(),
            self.banking_stage.join(),
            self.forwarding_stage.join(),
            self.staked_nodes_updater_service.join(),
            self.tpu_quic_t.map_or(Ok(()), |t| t.join()),
            self.tpu_forwards_quic_t.map_or(Ok(()), |t| t.join()),
            self.tpu_vote_quic_t.join(),
            self.bundle_stage.join(),
            self.bundle_sigverify_stage.join(),
            self.relayer_stage.join(),
            self.block_engine_stage.join(),
            self.fetch_stage_manager.join(),
        ];
        let broadcast_result = self.broadcast_stage.join();
        for result in results {
            result?;
        }
        if let Some(tpu_entry_notifier) = self.tpu_entry_notifier {
            tpu_entry_notifier.join()?;
        }
        let _ = broadcast_result?;
        if let Some(tracer_thread_hdl) = self.tracer_thread_hdl {
            if let Err(tracer_result) = tracer_thread_hdl.join()? {
                error!(
                    "banking tracer thread returned error after successful thread join: \
                     {tracer_result:?}"
                );
            }
        }
        Ok(())
    }
}

#[cfg(test)]
mod test {
    use {
        super::calculate_block_cost_limit_reservation,
        solana_ledger::genesis_utils::create_genesis_config, solana_pubkey::Pubkey,
        solana_runtime::bank::Bank, std::sync::Arc,
    };

    #[test]
    fn test_calculate_block_cost_limit_reservation() {
        const BUNDLE_BLOCK_COST_LIMITS_RESERVATION: u64 = 100;
        const RESERVED_TICKS: u64 = 5;
        let genesis_config_info = create_genesis_config(100);
        let bank = Arc::new(Bank::new_for_tests(&genesis_config_info.genesis_config));

        for _ in 0..genesis_config_info.genesis_config.ticks_per_slot {
            bank.register_default_tick_for_test();
        }
        assert!(bank.is_complete());
        bank.freeze();
        let bank1 = Arc::new(Bank::new_from_parent(bank.clone(), &Pubkey::default(), 1));

        // wait for reservation to be over
        (0..RESERVED_TICKS).for_each(|_| {
            assert_eq!(
                calculate_block_cost_limit_reservation(
                    &bank1,
                    RESERVED_TICKS,
                    BUNDLE_BLOCK_COST_LIMITS_RESERVATION,
                ),
                BUNDLE_BLOCK_COST_LIMITS_RESERVATION
            );
            bank1.register_default_tick_for_test();
        });
        assert_eq!(
            calculate_block_cost_limit_reservation(
                &bank1,
                RESERVED_TICKS,
                BUNDLE_BLOCK_COST_LIMITS_RESERVATION,
            ),
            0
        );
    }
}
