--- /Users/gabrielhicks/Staking/jito-mod/core/src/replay_stage.rs	2024-10-07 14:40:52
+++ /Users/gabrielhicks/Staking/jito-mod/jito-zan-ax/mod_files/core/src/replay_stage.rs	2024-10-07 14:43:03
@@ -624,6 +624,8 @@
                 &poh_recorder,
                 &leader_schedule_cache,
             );
+
+            let mut last_logged_vote_slot: Slot = u64::MAX;
 
             loop {
                 // Stop getting entries if we get exit signal
@@ -805,7 +807,7 @@
                 let mut compute_slot_stats_time = Measure::start("compute_slot_stats_time");
                 for slot in newly_computed_slot_stats {
                     let fork_stats = progress.get_fork_stats(slot).unwrap();
-                    let confirmed_slots = Self::confirm_forks(
+                    let (confirmed_slots, mostly_confirmed_slots) = Self::confirm_forks(
                         &tower,
                         &fork_stats.voted_stakes,
                         fork_stats.total_stake,
@@ -815,6 +817,7 @@
 
                     Self::mark_slots_confirmed(
                         &confirmed_slots,
+                        &mostly_confirmed_slots,
                         &blockstore,
                         &bank_forks,
                         &mut progress,
@@ -862,6 +865,7 @@
                     &mut tower,
                     &latest_validator_votes_for_frozen_banks,
                     &heaviest_subtree_fork_choice,
+                    &mut last_logged_vote_slot,
                 );
                 select_vote_and_reset_forks_time.stop();
 
@@ -903,6 +907,8 @@
                 }
                 heaviest_fork_failures_time.stop();
 
+                tower.update_config();
+
                 let mut voting_time = Measure::start("voting_time");
                 // Vote on a fork
                 if let Some((ref vote_bank, ref switch_fork_decision)) = vote_bank {
@@ -917,35 +923,238 @@
                         );
                     }
 
-                    Self::handle_votable_bank(
-                        vote_bank,
-                        switch_fork_decision,
-                        &bank_forks,
-                        &mut tower,
-                        &mut progress,
-                        &vote_account,
-                        &identity_keypair,
-                        &authorized_voter_keypairs.read().unwrap(),
-                        &blockstore,
-                        &leader_schedule_cache,
-                        &lockouts_sender,
-                        &accounts_background_request_sender,
-                        &latest_root_senders,
-                        &rpc_subscriptions,
-                        &block_commitment_cache,
-                        &mut heaviest_subtree_fork_choice,
-                        &bank_notification_sender,
-                        &mut duplicate_slots_tracker,
-                        &mut duplicate_confirmed_slots,
-                        &mut unfrozen_gossip_verified_vote_hashes,
-                        &mut voted_signatures,
-                        &mut has_new_vote_been_rooted,
-                        &mut replay_timing,
-                        &voting_sender,
-                        &mut epoch_slots_frozen_slots,
-                        &drop_bank_sender,
-                        wait_to_vote_slot,
-                    );
+                    let mut vote_banks = vec![];
+                    let mut pop_expired = true;
+
+                    // If threshold voting is enabled ...
+                    if let Some(threshold_ahead_count) = tower.get_threshold_ahead_count() {
+                        // The most recent voted slot will be needed
+                        let most_recent_voted_slot = tower.tower_slots().last().cloned();
+
+                        // Find the newest mostly_confirmed_bank on vote_bank's fork
+                        if let Some(mostly_confirmed_bank) =
+                            ReplayStage::first_mostly_confirmed_bank(vote_bank.clone(), &progress)
+                        {
+                            // If there is a prior vote, then take all banks between the most recently voted slot and
+                            // the new mostly_confirmed_bank, but not including either (the mostly_confirmed bank will
+                            // be included in the extend below).
+                            if let Some(most_recent_voted_slot) = most_recent_voted_slot {
+                                if let Some(mostly_confirmed_bank_parent) =
+                                    mostly_confirmed_bank.parent()
+                                {
+                                    vote_banks = ReplayStage::banks_between_and_including(
+                                        most_recent_voted_slot + 1,
+                                        mostly_confirmed_bank_parent.clone(),
+                                    );
+                                }
+                            }
+
+                            // Also take the mostly_confirmed bank plus threshold_ahead_count banks after it, up to
+                            // vote_bank.  If mostly_confirmed_bank is at or before the most recently voted slot, then
+                            // slots already voted on will be included, but will be removed by the filter operation
+                            // that follows this.
+                            vote_banks.extend(
+                                ReplayStage::banks_between_and_including(
+                                    mostly_confirmed_bank.slot(),
+                                    vote_bank.clone(),
+                                )
+                                .into_iter()
+                                .take((threshold_ahead_count + 1) as usize)
+                                .collect::<Vec<Arc<Bank>>>(),
+                            );
+
+                            // Filter out:
+                            // 1. Already-voted-on banks
+                            // 2. Any banks which can't be voted on because they are locked out
+                            // 3. If there is a "skip ahead threshold", all votes after a skip if the first vote after
+                            //    the skip doesn't meet the threshold.
+                            // 4. All except the first 31 votes that aren't filtered by 1 - 3.
+                            let after_skip_threshold = tower.get_after_skip_threshold();
+                            let mut filtered_vote_banks = vec![];
+                            let mut filtered_vote_slots = vec![];
+                            for bank in &vote_banks {
+                                // 1
+                                if bank.slot() <= most_recent_voted_slot.unwrap_or(0) {
+                                    continue;
+                                }
+                                // 2
+                                if tower.is_locked_out_including(
+                                    bank.slot(),
+                                    ancestors.get(&bank.slot()).unwrap(),
+                                    &filtered_vote_slots,
+                                ) {
+                                    info!(
+                                        "vote-optimizer cannot vote on {} because it's locked out",
+                                        bank.slot()
+                                    );
+                                    continue;
+                                }
+                                // 3
+                                if bank.slot()
+                                    > (bank.parent().map(|parent| parent.slot()).unwrap_or(0) + 1)
+                                {
+                                    match after_skip_threshold {
+                                        Some(1) => {
+                                            if !progress
+                                                .get_fork_stats(bank.slot())
+                                                .unwrap()
+                                                .is_mostly_confirmed
+                                            {
+                                                info!(
+                                                    "vote-optimizer after skip refusing {}",
+                                                    bank.slot()
+                                                );
+                                                break;
+                                            }
+                                        }
+                                        Some(2) => {
+                                            if !progress
+                                                .get_fork_stats(bank.slot())
+                                                .unwrap()
+                                                .is_supermajority_confirmed
+                                            {
+                                                info!(
+                                                    "vote-optimizer after skip refusing {}",
+                                                    bank.slot()
+                                                );
+                                                break;
+                                            }
+                                        }
+                                        _ => (),
+                                    }
+                                }
+                                filtered_vote_banks.push(bank.clone());
+                                // 4
+                                if filtered_vote_banks.len() == 31 {
+                                    break;
+                                }
+                                filtered_vote_slots.push(bank.slot());
+                            }
+
+                            // Now filter out any banks which would increase lockout past the most recently
+                            // confirmed slot on this fork to > 64.  Remove the newest first so that they can
+                            // be voted on later if they end up being votable.
+                            if !filtered_vote_banks.is_empty() {
+                                let first_slot_to_not_lock_out =
+                                    ReplayStage::last_confirmed_slot(vote_bank, &progress) + 65;
+                                tower.pop_votes_locked_out_at(
+                                    &mut filtered_vote_slots,
+                                    first_slot_to_not_lock_out,
+                                );
+                                if filtered_vote_banks.len() > filtered_vote_slots.len() {
+                                    info!(
+                                        "vote-optimizer cannot vote on {} or subsequent slots because lockout would \
+                                         exceed slot {}",
+                                        filtered_vote_banks[filtered_vote_slots.len()].slot(),
+                                        first_slot_to_not_lock_out - 1);
+                                    filtered_vote_banks.truncate(filtered_vote_slots.len());
+                                }
+                            }
+
+                            vote_banks = filtered_vote_banks;
+
+                            // If there are no banks included, then check to see if there are more than
+                            // threshold_escape_count banks since the last voted bank that have not been voted on yet.
+                            // If there are, vote for the oldest not voted on bank, so as not to get too far behind
+                            // the cluster and miss voting opportunities.
+                            if vote_banks.is_empty() {
+                                if let Some(threshold_escape_count) =
+                                    tower.get_threshold_escape_count()
+                                {
+                                    if let Some(most_recent_voted_slot) = most_recent_voted_slot {
+                                        // Get all banks that could be voted on, which doesn't include banks that
+                                        // can't be voted on because they would be locked out
+                                        let mut unvoted_banks = vec![];
+                                        let mut unvoted_slots = vec![];
+                                        for bank in ReplayStage::banks_between_and_including(
+                                            most_recent_voted_slot + 1,
+                                            vote_bank.clone(),
+                                        ) {
+                                            if !tower.is_locked_out_including(
+                                                bank.slot(),
+                                                ancestors.get(&bank.slot()).unwrap(),
+                                                &unvoted_slots,
+                                            ) {
+                                                unvoted_banks.push(bank.clone());
+                                                unvoted_slots.push(bank.slot());
+                                            }
+                                        }
+
+                                        if unvoted_banks.len() > (threshold_escape_count as usize) {
+                                            info!(
+                                                "vote-optimizer voting on escape slot {}",
+                                                unvoted_banks[0].slot()
+                                            );
+                                            vote_banks.push(unvoted_banks[0].clone());
+                                        }
+                                    } else {
+                                        // Else have never voted; in this case, just vote on the proposed bank
+                                        info!(
+                                            "vote-optimizer never voted, so voting on {}",
+                                            vote_bank.slot()
+                                        );
+                                        vote_banks.push(vote_bank.clone());
+                                    }
+                                }
+                            }
+
+                            // Now expire votes from the tower's vote_state if they are on a different fork than the
+                            // votes.  Expiring only these votes is only allowed with VoteStateUpdate, which no longer
+                            // requires expiration of on-fork votes.
+                            if let Some(last_new_vote) = vote_banks.last() {
+                                let ancestors = ancestors.get(&last_new_vote.slot()).unwrap();
+                                while let Some(vote) = tower.vote_state.last_lockout() {
+                                    // If the vote is not an ancestor of the bank, then we must have just
+                                    // switched forks away from it, so remove it from the tower
+                                    if !ancestors.contains(&vote.slot()) {
+                                        info!("vote-optimizer purged {}", vote.slot());
+                                        tower.vote_state.votes.pop_back();
+                                    } else {
+                                        break;
+                                    }
+                                }
+                            }
+                            // Arrange for process_next_vote_slot() to be called with a flag telling it not to do
+                            // any popping since if there was any popping to be done, we already did it.
+                            pop_expired = false;
+                        }
+                    } else {
+                        // Not threshold voting, so just vote on the proposed bank
+                        vote_banks.push(vote_bank.clone());
+                    }
+
+                    if !vote_banks.is_empty() {
+                        Self::handle_votable_banks(
+                            &vote_banks,
+                            switch_fork_decision,
+                            &bank_forks,
+                            &mut tower,
+                            &mut progress,
+                            &vote_account,
+                            &identity_keypair,
+                            &authorized_voter_keypairs.read().unwrap(),
+                            &blockstore,
+                            &leader_schedule_cache,
+                            &lockouts_sender,
+                            &accounts_background_request_sender,
+                            &latest_root_senders,
+                            &rpc_subscriptions,
+                            &block_commitment_cache,
+                            &mut heaviest_subtree_fork_choice,
+                            &bank_notification_sender,
+                            &mut duplicate_slots_tracker,
+                            &mut duplicate_confirmed_slots,
+                            &mut unfrozen_gossip_verified_vote_hashes,
+                            &mut voted_signatures,
+                            &mut has_new_vote_been_rooted,
+                            &mut replay_timing,
+                            &voting_sender,
+                            &mut epoch_slots_frozen_slots,
+                            &drop_bank_sender,
+                            wait_to_vote_slot,
+                            pop_expired,
+                        );
+                    }
                 }
                 voting_time.stop();
 
@@ -1262,9 +1471,59 @@
                 progress,
                 latest_leader_slot,
             );
+        }
+    }
+
+    fn first_mostly_confirmed_bank(bank: Arc<Bank>, progress: &ProgressMap) -> Option<Arc<Bank>> {
+        if progress
+            .get_fork_stats(bank.slot())
+            .unwrap()
+            .is_mostly_confirmed
+        {
+            Some(bank.clone())
+        } else if let Some(parent) = bank.parent() {
+            ReplayStage::first_mostly_confirmed_bank(parent.clone(), progress)
+        } else {
+            None
+        }
+    }
+
+    fn last_confirmed_slot(bank: &Bank, progress: &ProgressMap) -> Slot {
+        if progress
+            .get_fork_stats(bank.slot())
+            .unwrap()
+            .is_supermajority_confirmed
+        {
+            bank.slot()
+        } else if let Some(parent) = bank.parent() {
+            ReplayStage::last_confirmed_slot(&parent, progress)
+        } else {
+            0
         }
     }
 
+    fn banks_between_and_including(first_slot: u64, last_bank: Arc<Bank>) -> Vec<Arc<Bank>> {
+        let mut banks = vec![];
+
+        let mut bank = last_bank;
+
+        loop {
+            if bank.slot() < first_slot {
+                break;
+            }
+
+            banks.push(bank.clone());
+
+            if let Some(parent) = bank.parent() {
+                bank = parent.clone();
+            } else {
+                break;
+            }
+        }
+
+        banks.into_iter().rev().collect()
+    }
+
     fn is_partition_detected(
         ancestors: &HashMap<Slot, HashSet<Slot>>,
         last_voted_slot: Slot,
@@ -2213,8 +2472,8 @@
     }
 
     #[allow(clippy::too_many_arguments)]
-    fn handle_votable_bank(
-        bank: &Arc<Bank>,
+    fn handle_votable_banks(
+        banks: &Vec<Arc<Bank>>,
         switch_fork_decision: &SwitchForkDecision,
         bank_forks: &Arc<RwLock<BankForks>>,
         tower: &mut Tower,
@@ -2241,100 +2500,113 @@
         epoch_slots_frozen_slots: &mut EpochSlotsFrozenSlots,
         drop_bank_sender: &Sender<Vec<Arc<Bank>>>,
         wait_to_vote_slot: Option<Slot>,
+        pop_expired: bool,
     ) {
-        if bank.is_empty() {
-            datapoint_info!("replay_stage-voted_empty_bank", ("slot", bank.slot(), i64));
-        }
-        trace!("handle votable bank {}", bank.slot());
-        let new_root = tower.record_bank_vote(bank);
+        assert!(!banks.is_empty());
 
-        if let Some(new_root) = new_root {
-            // get the root bank before squash
-            let root_bank = bank_forks
-                .read()
-                .unwrap()
-                .get(new_root)
-                .expect("Root bank doesn't exist");
-            let mut rooted_banks = root_bank.parents();
-            let oldest_parent = rooted_banks.last().map(|last| last.parent_slot());
-            rooted_banks.push(root_bank.clone());
-            let rooted_slots: Vec<_> = rooted_banks.iter().map(|bank| bank.slot()).collect();
-            // The following differs from  rooted_slots by including the parent slot of the oldest parent bank.
-            let rooted_slots_with_parents = bank_notification_sender
-                .as_ref()
-                .map_or(false, |sender| sender.should_send_parents)
-                .then(|| {
-                    let mut new_chain = rooted_slots.clone();
-                    new_chain.push(oldest_parent.unwrap_or_else(|| bank.parent_slot()));
-                    new_chain
-                });
+        // Track the newly voted on slots so that they can be logged
+        let mut new_slots = vec![];
 
-            // Call leader schedule_cache.set_root() before blockstore.set_root() because
-            // bank_forks.root is consumed by repair_service to update gossip, so we don't want to
-            // get shreds for repair on gossip before we update leader schedule, otherwise they may
-            // get dropped.
-            leader_schedule_cache.set_root(rooted_banks.last().unwrap());
-            blockstore
-                .set_roots(rooted_slots.iter())
-                .expect("Ledger set roots failed");
-            let highest_super_majority_root = Some(
-                block_commitment_cache
+        for bank in banks.iter() {
+            if bank.is_empty() {
+                datapoint_info!("replay_stage-voted_empty_bank", ("slot", bank.slot(), i64));
+            }
+            new_slots.push(bank.slot());
+            trace!("handle votable bank {}", bank.slot());
+            let new_root = tower.record_bank_vote(bank, pop_expired);
+
+            if let Some(new_root) = new_root {
+                // get the root bank before squash
+                let root_bank = bank_forks
                     .read()
                     .unwrap()
-                    .highest_super_majority_root(),
-            );
-            Self::handle_new_root(
-                new_root,
-                bank_forks,
-                progress,
-                accounts_background_request_sender,
-                highest_super_majority_root,
-                heaviest_subtree_fork_choice,
-                duplicate_slots_tracker,
-                duplicate_confirmed_slots,
-                unfrozen_gossip_verified_vote_hashes,
-                has_new_vote_been_rooted,
-                vote_signatures,
-                epoch_slots_frozen_slots,
-                drop_bank_sender,
-            );
+                    .get(new_root)
+                    .expect("Root bank doesn't exist");
+                let mut rooted_banks = root_bank.parents();
+                let oldest_parent = rooted_banks.last().map(|last| last.parent_slot());
+                rooted_banks.push(root_bank.clone());
+                let rooted_slots: Vec<_> = rooted_banks.iter().map(|bank| bank.slot()).collect();
+                // The following differs from  rooted_slots by including the parent slot of the oldest parent bank.
+                let rooted_slots_with_parents = bank_notification_sender
+                    .as_ref()
+                    .map_or(false, |sender| sender.should_send_parents)
+                    .then(|| {
+                        let mut new_chain = rooted_slots.clone();
+                        new_chain.push(oldest_parent.unwrap_or_else(|| bank.parent_slot()));
+                        new_chain
+                    });
 
-            blockstore.slots_stats.mark_rooted(new_root);
-
-            rpc_subscriptions.notify_roots(rooted_slots);
-            if let Some(sender) = bank_notification_sender {
-                sender
-                    .sender
-                    .send(BankNotification::NewRootBank(root_bank))
-                    .unwrap_or_else(|err| warn!("bank_notification_sender failed: {:?}", err));
+                // Call leader schedule_cache.set_root() before blockstore.set_root() because
+                // bank_forks.root is consumed by repair_service to update gossip, so we don't want to
+                // get shreds for repair on gossip before we update leader schedule, otherwise they may
+                // get dropped.
+                leader_schedule_cache.set_root(rooted_banks.last().unwrap());
+                blockstore
+                    .set_roots(rooted_slots.iter())
+                    .expect("Ledger set roots failed");
+                let highest_super_majority_root = Some(
+                    block_commitment_cache
+                        .read()
+                        .unwrap()
+                        .highest_super_majority_root(),
+                );
+                Self::handle_new_root(
+                    new_root,
+                    bank_forks,
+                    progress,
+                    accounts_background_request_sender,
+                    highest_super_majority_root,
+                    heaviest_subtree_fork_choice,
+                    duplicate_slots_tracker,
+                    duplicate_confirmed_slots,
+                    unfrozen_gossip_verified_vote_hashes,
+                    has_new_vote_been_rooted,
+                    vote_signatures,
+                    epoch_slots_frozen_slots,
+                    drop_bank_sender,
+                );
 
-                if let Some(new_chain) = rooted_slots_with_parents {
+                blockstore.slots_stats.mark_rooted(new_root);
+
+                rpc_subscriptions.notify_roots(rooted_slots);
+                if let Some(sender) = bank_notification_sender {
                     sender
                         .sender
-                        .send(BankNotification::NewRootedChain(new_chain))
+                        .send(BankNotification::NewRootBank(root_bank))
                         .unwrap_or_else(|err| warn!("bank_notification_sender failed: {:?}", err));
+
+                    if let Some(new_chain) = rooted_slots_with_parents {
+                        sender
+                            .sender
+                            .send(BankNotification::NewRootedChain(new_chain))
+                            .unwrap_or_else(|err| {
+                                warn!("bank_notification_sender failed: {:?}", err)
+                            });
+                    }
                 }
+                latest_root_senders.iter().for_each(|s| {
+                    if let Err(e) = s.send(new_root) {
+                        trace!("latest root send failed: {:?}", e);
+                    }
+                });
+                info!("new root {}", new_root);
             }
-            latest_root_senders.iter().for_each(|s| {
-                if let Err(e) = s.send(new_root) {
-                    trace!("latest root send failed: {:?}", e);
-                }
-            });
-            info!("new root {}", new_root);
+
+            let mut update_commitment_cache_time = Measure::start("update_commitment_cache");
+            Self::update_commitment_cache(
+                bank.clone(),
+                bank_forks.read().unwrap().root(),
+                progress.get_fork_stats(bank.slot()).unwrap().total_stake,
+                lockouts_sender,
+            );
+            update_commitment_cache_time.stop();
+            replay_timing.update_commitment_cache_us += update_commitment_cache_time.as_us();
         }
 
-        let mut update_commitment_cache_time = Measure::start("update_commitment_cache");
-        Self::update_commitment_cache(
-            bank.clone(),
-            bank_forks.read().unwrap().root(),
-            progress.get_fork_stats(bank.slot()).unwrap().total_stake,
-            lockouts_sender,
-        );
-        update_commitment_cache_time.stop();
-        replay_timing.update_commitment_cache_us += update_commitment_cache_time.as_us();
+        info!("voting for window: {:?}", new_slots);
 
         Self::push_vote(
-            bank,
+            banks.last().unwrap(),
             vote_account_pubkey,
             identity_keypair,
             authorized_voter_keypairs,
@@ -3560,6 +3832,7 @@
         tower: &mut Tower,
         latest_validator_votes_for_frozen_banks: &LatestValidatorVotesForFrozenBanks,
         fork_choice: &HeaviestSubtreeForkChoice,
+        last_logged_vote_slot: &mut Slot,
     ) -> SelectVoteAndResetForkResult {
         // Try to vote on the actual heaviest fork. If the heaviest bank is
         // locked out or fails the threshold check, the validator will:
@@ -3760,11 +4033,14 @@
                 && propagation_confirmed
                 && switch_fork_decision.can_vote()
             {
-                info!(
-                    "voting: {} {:.1}%",
-                    candidate_vote_bank.slot(),
-                    100.0 * fork_weight
-                );
+                if candidate_vote_bank.slot() != *last_logged_vote_slot {
+                    info!(
+                        "voting: {} {:.1}%",
+                        candidate_vote_bank.slot(),
+                        100.0 * fork_weight
+                    );
+                    *last_logged_vote_slot = candidate_vote_bank.slot();
+                }
                 SelectVoteAndResetForkResult {
                     vote_bank: Some((candidate_vote_bank.clone(), switch_fork_decision)),
                     reset_bank: Some(candidate_vote_bank.clone()),
@@ -3919,6 +4195,7 @@
     #[allow(clippy::too_many_arguments)]
     fn mark_slots_confirmed(
         confirmed_slots: &[ConfirmedSlot],
+        mostly_confirmed_forks: &[Slot],
         blockstore: &Blockstore,
         bank_forks: &RwLock<BankForks>,
         progress: &mut ProgressMap,
@@ -3988,6 +4265,9 @@
                 SlotStateUpdate::DuplicateConfirmed(duplicate_confirmed_state),
             );
         }
+        for slot in mostly_confirmed_forks.iter() {
+            progress.set_mostly_confirmed_slot(*slot);
+        }
     }
 
     fn confirm_forks(
@@ -3996,8 +4276,9 @@
         total_stake: Stake,
         progress: &ProgressMap,
         bank_forks: &RwLock<BankForks>,
-    ) -> Vec<ConfirmedSlot> {
+    ) -> (Vec<ConfirmedSlot>, Vec<Slot>) {
         let mut confirmed_forks = vec![];
+        let mut mostly_confirmed_forks = vec![];
         for (slot, prog) in progress.iter() {
             if !prog.fork_stats.is_supermajority_confirmed {
                 let bank = bank_forks
@@ -4041,9 +4322,14 @@
                         voted_stakes.get(slot)
                     );
                 }
+                if bank.is_frozen()
+                    && tower.is_slot_mostly_confirmed(*slot, voted_stakes, total_stake)
+                {
+                    mostly_confirmed_forks.push(*slot);
+                }
             }
         }
-        confirmed_forks
+        (confirmed_forks, mostly_confirmed_forks)
     }
 
     #[allow(clippy::too_many_arguments)]
@@ -5345,7 +5631,7 @@
         // bank 1, so no slot should be confirmed.
         {
             let fork_progress = progress.get(&0).unwrap();
-            let confirmed_forks = ReplayStage::confirm_forks(
+            let (confirmed_forks, _) = ReplayStage::confirm_forks(
                 &tower,
                 &fork_progress.fork_stats.voted_stakes,
                 fork_progress.fork_stats.total_stake,
@@ -5395,7 +5681,7 @@
         assert_eq!(newly_computed, vec![1]);
         {
             let fork_progress = progress.get(&1).unwrap();
-            let confirmed_forks = ReplayStage::confirm_forks(
+            let (confirmed_forks, _) = ReplayStage::confirm_forks(
                 &tower,
                 &fork_progress.fork_stats.voted_stakes,
                 fork_progress.fork_stats.total_stake,
@@ -6712,7 +6998,7 @@
         assert_eq!(reset_fork.unwrap(), 4);
 
         // Record the vote for 5 which is not on the heaviest fork.
-        tower.record_bank_vote(&bank_forks.read().unwrap().get(5).unwrap());
+        tower.record_bank_vote(&bank_forks.read().unwrap().get(5).unwrap(), true);
 
         // 4 should be the heaviest slot, but should not be votable
         // because of lockout. 5 is the heaviest slot on the same fork as the last vote.
@@ -6930,7 +7216,7 @@
         assert_eq!(reset_fork.unwrap(), 4);
 
         // Record the vote for 4
-        tower.record_bank_vote(&bank_forks.read().unwrap().get(4).unwrap());
+        tower.record_bank_vote(&bank_forks.read().unwrap().get(4).unwrap(), true);
 
         // Mark 4 as duplicate, 3 should be the heaviest slot, but should not be votable
         // because of lockout
@@ -7164,7 +7450,7 @@
             ..
         } = vote_simulator;
 
-        tower.record_bank_vote(&bank_forks.read().unwrap().get(first_vote).unwrap());
+        tower.record_bank_vote(&bank_forks.read().unwrap().get(first_vote).unwrap(), true);
 
         // Simulate another version of slot 2 was duplicate confirmed
         let our_bank2_hash = bank_forks.read().unwrap().bank_hash(2).unwrap();
@@ -7282,6 +7568,7 @@
             .select_forks(&frozen_banks, &tower, &progress, &ancestors, &bank_forks);
         assert_eq!(heaviest_bank.slot(), 7);
         assert!(heaviest_bank_on_same_fork.is_none());
+        let mut junk = 0;
         ReplayStage::select_vote_and_reset_forks(
             &heaviest_bank,
             heaviest_bank_on_same_fork.as_ref(),
@@ -7291,6 +7578,7 @@
             &mut tower,
             &latest_validator_votes_for_frozen_banks,
             &heaviest_subtree_fork_choice,
+            &mut junk,
         )
     }
 
@@ -7405,6 +7693,7 @@
             .select_forks(&frozen_banks, &tower, &progress, &ancestors, &bank_forks);
         assert_eq!(heaviest_bank.slot(), 5);
         assert!(heaviest_bank_on_same_fork.is_none());
+        let mut junk = 0;
         ReplayStage::select_vote_and_reset_forks(
             &heaviest_bank,
             heaviest_bank_on_same_fork.as_ref(),
@@ -7414,6 +7703,7 @@
             &mut tower,
             &latest_validator_votes_for_frozen_banks,
             &heaviest_subtree_fork_choice,
+            &mut junk,
         )
     }
 
@@ -7561,7 +7851,7 @@
             1,
         );
         bank1.fill_bank_with_ticks_for_tests();
-        tower.record_bank_vote(&bank0);
+        tower.record_bank_vote(&bank0, true);
         ReplayStage::push_vote(
             &bank0,
             &my_vote_pubkey,
@@ -7636,7 +7926,7 @@
 
         // Simulate submitting a new vote for bank 1 to the network, but the vote
         // not landing
-        tower.record_bank_vote(&bank1);
+        tower.record_bank_vote(&bank1, true);
         ReplayStage::push_vote(
             &bank1,
             &my_vote_pubkey,
@@ -7837,7 +8127,7 @@
         progress: &mut ProgressMap,
     ) -> Arc<Bank> {
         let my_vote_pubkey = &my_vote_keypair[0].pubkey();
-        tower.record_bank_vote(&parent_bank);
+        tower.record_bank_vote(&parent_bank, true);
         ReplayStage::push_vote(
             &parent_bank,
             my_vote_pubkey,
@@ -8041,6 +8331,7 @@
         assert_eq!(tower.last_voted_slot(), Some(last_voted_slot));
         assert_eq!(progress.my_latest_landed_vote(tip_of_voted_fork), Some(0));
         let other_fork_bank = &bank_forks.read().unwrap().get(other_fork_slot).unwrap();
+        let mut junk = 0;
         let SelectVoteAndResetForkResult { vote_bank, .. } =
             ReplayStage::select_vote_and_reset_forks(
                 other_fork_bank,
@@ -8051,6 +8342,7 @@
                 &mut tower,
                 &latest_validator_votes_for_frozen_banks,
                 &heaviest_subtree_fork_choice,
+                &mut junk,
             );
         assert!(vote_bank.is_some());
         assert_eq!(vote_bank.unwrap().0.slot(), tip_of_voted_fork);
@@ -8058,6 +8350,7 @@
         // If last vote is already equal to heaviest_bank_on_same_voted_fork,
         // we should not vote.
         let last_voted_bank = &bank_forks.read().unwrap().get(last_voted_slot).unwrap();
+        let mut junk = 0;
         let SelectVoteAndResetForkResult { vote_bank, .. } =
             ReplayStage::select_vote_and_reset_forks(
                 other_fork_bank,
@@ -8068,12 +8361,14 @@
                 &mut tower,
                 &latest_validator_votes_for_frozen_banks,
                 &heaviest_subtree_fork_choice,
+                &mut junk,
             );
         assert!(vote_bank.is_none());
 
         // If last vote is still inside slot hashes history of heaviest_bank_on_same_voted_fork,
         // we should not vote.
         let last_voted_bank_plus_1 = &bank_forks.read().unwrap().get(last_voted_slot + 1).unwrap();
+        let mut junk = 0;
         let SelectVoteAndResetForkResult { vote_bank, .. } =
             ReplayStage::select_vote_and_reset_forks(
                 other_fork_bank,
@@ -8084,6 +8379,7 @@
                 &mut tower,
                 &latest_validator_votes_for_frozen_banks,
                 &heaviest_subtree_fork_choice,
+                &mut junk,
             );
         assert!(vote_bank.is_none());
 
@@ -8092,6 +8388,7 @@
             .entry(new_bank.slot())
             .and_modify(|s| s.fork_stats.my_latest_landed_vote = Some(last_voted_slot));
         assert!(!new_bank.is_in_slot_hashes_history(&last_voted_slot));
+        let mut junk = 0;
         let SelectVoteAndResetForkResult { vote_bank, .. } =
             ReplayStage::select_vote_and_reset_forks(
                 other_fork_bank,
@@ -8102,6 +8399,7 @@
                 &mut tower,
                 &latest_validator_votes_for_frozen_banks,
                 &heaviest_subtree_fork_choice,
+                &mut junk,
             );
         assert!(vote_bank.is_none());
     }
@@ -8444,6 +8742,7 @@
         );
         let (heaviest_bank, heaviest_bank_on_same_fork) = heaviest_subtree_fork_choice
             .select_forks(&frozen_banks, tower, progress, ancestors, bank_forks);
+        let mut junk = 0;
         let SelectVoteAndResetForkResult {
             vote_bank,
             reset_bank,
@@ -8457,6 +8756,7 @@
             tower,
             latest_validator_votes_for_frozen_banks,
             heaviest_subtree_fork_choice,
+            &mut junk,
         );
         (
             vote_bank.map(|(b, _)| b.slot()),
